{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE NoImplicitPrelude #-}


module Data.Aeson.Tagged
(
    -- * Classes
    -- $classes
    FromJSON(..),
    ToJSON(..),

    -- * Interop between aeson and tagged-aeson
    Aeson,
    TaggedAeson(..), fromTaggedAeson,

    -- * Defining instances
    -- $generic
    deriveJSON,
    deriveToJSON,
    deriveFromJSON,
    -- ** Internals
    addTag,

    -- * Combinators
    (.:), (.:?), (.:!),
    A.withObject, A.withText, A.withArray, A.withScientific, A.withBool,
)
where


import BasePrelude
import qualified Data.Vector as V
import Data.Text (Text)
import Data.Generics.Uniplate.Data (transformBi)
import Language.Haskell.TH

-- aeson
import qualified Data.Aeson          as A
import qualified Data.Aeson.Types    as A
import qualified Data.Aeson.Internal as A
import qualified Data.Aeson.TH       as A
import Data.Aeson (Encoding, Object, Value(..))
import Data.Aeson.Types (Parser, typeMismatch)
import qualified Data.Aeson.Encoding as E


----------------------------------------------------------------------------
-- Classes
----------------------------------------------------------------------------

-- $classes
--
-- This are tagged analogs of 'A.FromJSON' and 'A.ToJSON' from Aeson. You
-- can write your own instances of these classes, or you can use
-- 'deriveJSON' to autoderive them. Note that generic instances don't work.

class FromJSON (tag :: k) a where
    parseJSON :: Value -> Parser a

    parseJSONList :: Value -> Parser [a]
    parseJSONList (Array a)
        = zipWithM (parseIndexedJSON (parseJSON @tag)) [0..]
        . V.toList
        $ a

    parseJSONList v = typeMismatch "[a]" v

class ToJSON (tag :: k) a where
    toJSON :: a -> Value

    toEncoding :: a -> Encoding
    toEncoding = E.value . toJSON @tag
    {-# INLINE toEncoding #-}

    toJSONList :: [a] -> Value
    toJSONList = A.listValue (toJSON @tag)
    {-# INLINE toJSONList #-}

    toEncodingList :: [a] -> Encoding
    toEncodingList = A.listEncoding (toEncoding @tag)
    {-# INLINE toEncodingList #-}

----------------------------------------------------------------------------
-- Interop between aeson and tagged-aeson
----------------------------------------------------------------------------

-- | The tag for original @aeson@ instances. You can use @parseJSON \@Aeson@
-- and @toJSON \@Aeson@ to get aeson's parsing behavior.
data Aeson

instance A.FromJSON a => FromJSON Aeson a where
    parseJSON = A.parseJSON
    parseJSONList = A.parseJSONList

instance A.ToJSON a => ToJSON Aeson a where
    toJSON = A.toJSON
    toEncoding = A.toEncoding
    toJSONList = A.toJSONList
    toEncodingList = A.toEncodingList

-- | A newtype wrapper to use tagged-aeson instances with functions from
-- @aeson@ (or @yaml@).
newtype TaggedAeson (tag :: k) a = TaggedAeson a
    deriving (Eq, Ord, Show)

fromTaggedAeson :: TaggedAeson tag a -> a
fromTaggedAeson (TaggedAeson a) = a

instance FromJSON tag a => A.FromJSON (TaggedAeson tag a) where
    parseJSON =
        coerce @(Value -> Parser a) @(Value -> Parser (TaggedAeson tag a))
        (parseJSON @tag)
    parseJSONList =
        coerce @(Value -> Parser [a]) @(Value -> Parser [TaggedAeson tag a])
        (parseJSONList @tag)

----------------------------------------------------------------------------
-- Defining instances
----------------------------------------------------------------------------

-- $generic
--
-- We do not support generic instances. Instead of writing
--
-- @
-- instance FromJSON Tag Type
-- instance ToJSON Tag Type
-- @
--
-- you need to use 'deriveJSON':
--
-- @
-- deriveJSON ''Tag defaultOptions ''Type
-- @
--
-- You can also use 'deriveFromJSON' and 'deriveToJSON' to get just one
-- instance or the other.

deriveJSON
    :: Name        -- ^ Name of the tag to use for the instances
    -> A.Options   -- ^ Encoding options
    -> Name        -- ^ Name of the type for which to generate
                   --    'ToJSON' and 'FromJSON' instances
    -> Q [Dec]
deriveJSON tag opts name = addTag tag <$> A.deriveJSON opts name

deriveFromJSON
    :: Name        -- ^ Name of the tag to use for the instance
    -> A.Options   -- ^ Encoding options
    -> Name        -- ^ Name of the type for which to generate
                   --    a 'FromJSON' instance
    -> Q [Dec]
deriveFromJSON tag opts name = addTag tag <$> A.deriveFromJSON opts name

deriveToJSON
    :: Name        -- ^ Name of the tag to use for the instance
    -> A.Options   -- ^ Encoding options
    -> Name        -- ^ Name of the type for which to generate
                   --    a 'ToJSON' instance
    -> Q [Dec]
deriveToJSON tag opts name = addTag tag <$> A.deriveToJSON opts name

-- | This function rewrites instances generated by Aeson (by replacing
-- references to Aeson's classes and methods to our own classes and
-- methods).
--
-- The tag must be a name of a type.
addTag :: Name -> [Dec] -> [Dec]
addTag tag = transformBi rewriteExp . transformBi rewriteType
  where
    rewriteType a = case lookup a types of
        Just taggedA -> AppT taggedA (ConT tag)
        Nothing -> a
    types =
        [ (ConT ''A.ToJSON  , ConT ''ToJSON)
        , (ConT ''A.FromJSON, ConT ''FromJSON) ]

    rewriteExp a = case lookup a exps of
        Just taggedA -> AppTypeE taggedA (ConT tag)
        Nothing -> a
    exps =
        [ (VarE 'A.toJSON        , VarE 'toJSON)
        , (VarE 'A.toJSONList    , VarE 'toJSONList)
        , (VarE 'A.toEncoding    , VarE 'toEncoding)
        , (VarE 'A.toEncodingList, VarE 'toEncodingList)
        , (VarE 'A.parseJSON     , VarE 'parseJSON)
        , (VarE 'A.parseJSONList , VarE 'parseJSONList) ]

{-
keyValuePairWith
(.=)
parseUntaggedValue
parseTaggedObject
parseValue
consToValue
toPair
sumToValue

If the result has any FromJSON/ToJSON constraints from Aeson, it will not compile

todo: check what the different encoding of 'String' will change (will it change tags? I guess it shouldn't)
-}

----------------------------------------------------------------------------
-- Reimplementations
----------------------------------------------------------------------------

-- | Retrieve the value associated with the given key of an 'Object'.
-- The result is 'empty' if the key is not present or the value cannot
-- be converted to the desired type.
--
-- This accessor is appropriate if the key and value /must/ be present
-- in an object for it to be valid.  If the key and value are
-- optional, use '.:?' instead.
(.:) :: forall tag a. (FromJSON tag a) => Object -> Text -> Parser a
(.:) = A.explicitParseField (parseJSON @tag)
{-# INLINE (.:) #-}

-- | Retrieve the value associated with the given key of an 'Object'. The
-- result is 'Nothing' if the key is not present or if its value is 'Null',
-- or 'empty' if the value cannot be converted to the desired type.
--
-- This accessor is most useful if the key and value can be absent
-- from an object without affecting its validity.  If the key and
-- value are mandatory, use '.:' instead.
(.:?) :: forall tag a. (FromJSON tag a) => Object -> Text -> Parser (Maybe a)
(.:?) = A.explicitParseFieldMaybe (parseJSON @tag)
{-# INLINE (.:?) #-}

{-
(.:?) :: Object -> Text -> (forall tag a. FromJSON tag a => Parser (Maybe a))
(.:?) o f =
  let foo :: forall tag a. (FromJSON tag a) => Parser (Maybe a)
      foo = A.explicitParseFieldMaybe (parseJSON @tag) o f
  in foo
-}

-- | Retrieve the value associated with the given key of an 'Object'.
-- The result is 'Nothing' if the key is not present or 'empty' if the
-- value cannot be converted to the desired type.
--
-- This differs from '.:?' by attempting to parse 'Null' the same as any
-- other JSON value, instead of interpreting it as 'Nothing'.
(.:!) :: forall tag a. (FromJSON tag a) => Object -> Text -> Parser (Maybe a)
(.:!) = A.explicitParseFieldMaybe' (parseJSON @tag)
{-# INLINE (.:!) #-}

----------------------------------------------------------------------------
-- Assorted stuff ripped off from Aeson
----------------------------------------------------------------------------

parseIndexedJSON :: (Value -> Parser a) -> Int -> Value -> Parser a
parseIndexedJSON p idx value = p value A.<?> A.Index idx
{-# INLINE parseIndexedJSON #-}
