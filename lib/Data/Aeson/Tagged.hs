{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE NoImplicitPrelude #-}


module Data.Aeson.Tagged
(
  -- * Classes
  -- $classes
  FromJSON(..),
  ToJSON(..),

  -- * Predefined tags
  Aeson,

  -- * Defining instances
  -- $generic
  deriveJSON,
  deriveToJSON,
  deriveFromJSON,
  -- ** Internals
  addTag,
)
where


import BasePrelude
-- aeson
import qualified Data.Aeson          as A
import qualified Data.Aeson.Types    as A
import qualified Data.Aeson.Internal as A
import qualified Data.Aeson.TH       as A
import Data.Aeson (Encoding, Value(..))
import Data.Aeson.Types (Parser, typeMismatch)
import qualified Data.Aeson.Encoding as E
-- template-haskell
import Language.Haskell.TH
-- other stuff
import qualified Data.Vector as V
import Data.Generics.Uniplate.Data (transformBi)


----------------------------------------------------------------------------
-- Classes
----------------------------------------------------------------------------

-- $classes
--
-- This are tagged analogs of 'A.FromJSON' and 'A.ToJSON' from Aeson. You
-- can write your own instances of these classes, or you can use
-- 'deriveJSON' to autoderive them. Note that generic instances don't work.

class FromJSON tag a where
    parseJSON :: Value -> Parser a

    parseJSONList :: Value -> Parser [a]
    parseJSONList (Array a)
        = zipWithM (parseIndexedJSON (parseJSON @tag)) [0..]
        . V.toList
        $ a

    parseJSONList v = typeMismatch "[a]" v

class ToJSON tag a where
    toJSON :: a -> Value

    toEncoding :: a -> Encoding
    toEncoding = E.value . toJSON @tag
    {-# INLINE toEncoding #-}

    toJSONList :: [a] -> Value
    toJSONList = A.listValue (toJSON @tag)
    {-# INLINE toJSONList #-}

    toEncodingList :: [a] -> Encoding
    toEncodingList = A.listEncoding (toEncoding @tag)
    {-# INLINE toEncodingList #-}

----------------------------------------------------------------------------
-- Predefined tags
----------------------------------------------------------------------------

-- | The tag for original Aeson instances. You can use @parseJSON \@Aeson@
-- and @toJSON \@Aeson@ to get the original behavior.
data Aeson

instance A.FromJSON a => FromJSON Aeson a where
  parseJSON = A.parseJSON
  parseJSONList = A.parseJSONList

instance A.ToJSON a => ToJSON Aeson a where
  toJSON = A.toJSON
  toEncoding = A.toEncoding
  toJSONList = A.toJSONList
  toEncodingList = A.toEncodingList

----------------------------------------------------------------------------
-- Defining instances
----------------------------------------------------------------------------

-- $generic
--
-- We do not support generic instances. Instead of writing
--
-- @
-- instance FromJSON Tag Type
-- instance ToJSON Tag Type
-- @
--
-- you need to use 'deriveJSON':
--
-- @
-- deriveJSON ''Tag defaultOptions ''Type
-- @
--
-- You can also use 'deriveFromJSON' and 'deriveToJSON' to get just one
-- instance or the other.

deriveJSON
  :: Name        -- ^ Name of the tag to use for the instances
  -> A.Options   -- ^ Encoding options
  -> Name        -- ^ Name of the type for which to generate
                 --    'ToJSON' and 'FromJSON' instances
  -> Q [Dec]
deriveJSON tag opts name = addTag tag <$> A.deriveJSON opts name

deriveFromJSON
  :: Name        -- ^ Name of the tag to use for the instance
  -> A.Options   -- ^ Encoding options
  -> Name        -- ^ Name of the type for which to generate
                 --    a 'FromJSON' instance
  -> Q [Dec]
deriveFromJSON tag opts name = addTag tag <$> A.deriveFromJSON opts name

deriveToJSON
  :: Name        -- ^ Name of the tag to use for the instance
  -> A.Options   -- ^ Encoding options
  -> Name        -- ^ Name of the type for which to generate
                 --    a 'ToJSON' instance
  -> Q [Dec]
deriveToJSON tag opts name = addTag tag <$> A.deriveToJSON opts name

-- | This function rewrites instances generated by Aeson (by replacing
-- references to Aeson's classes and methods to our own classes and
-- methods).
--
-- The tag must be a name of a type.
addTag :: Name -> [Dec] -> [Dec]
addTag tag = transformBi rewriteExp . transformBi rewriteType
  where
    rewriteType a = case lookup a types of
      Just a' -> AppT a' (ConT tag)
      Nothing -> a
    rewriteExp a = case lookup a exps of
      -- We could use AppTypeE here but :(
      Just a' -> AppE a' (SigE (ConE 'Proxy)
                               (AppT (ConT ''Proxy) (ConT tag)))
      Nothing -> a
    --
    types =
      [ (ConT ''A.ToJSON  , ConT ''ToJSON)
      , (ConT ''A.FromJSON, ConT ''FromJSON) ]
    exps =
      [ (VarE 'A.toJSON        , VarE 'toJSONProxy)
      , (VarE 'A.toJSONList    , VarE 'toJSONListProxy)
      , (VarE 'A.toEncoding    , VarE 'toEncodingProxy)
      , (VarE 'A.toEncodingList, VarE 'toEncodingListProxy)
      , (VarE 'A.parseJSON     , VarE 'parseJSONProxy)
      , (VarE 'A.parseJSONList , VarE 'parseJSONListProxy) ]

-- Since AppTypeE is only supported on GHC > 8.0 (even though
-- TypeApplications are available earlier) we can't use AppTypeE in and have
-- to use proxified versions instead.

toJSONProxy
  :: forall tag a. ToJSON tag a
  => Proxy tag -> a -> Value
toJSONProxy _ = toJSON @tag

toJSONListProxy
  :: forall tag a. ToJSON tag a
  => Proxy tag -> [a] -> Value
toJSONListProxy _ = toJSONList @tag

toEncodingProxy
  :: forall tag a. ToJSON tag a
  => Proxy tag -> a -> Encoding
toEncodingProxy _ = toEncoding @tag

toEncodingListProxy
  :: forall tag a. ToJSON tag a
  => Proxy tag -> [a] -> Encoding
toEncodingListProxy _ = toEncodingList @tag

parseJSONProxy
  :: forall tag a. FromJSON tag a
  => Proxy tag -> Value -> Parser a
parseJSONProxy _ = parseJSON @tag

parseJSONListProxy
  :: forall tag a. FromJSON tag a
  => Proxy tag -> Value -> Parser [a]
parseJSONListProxy _ = parseJSONList @tag

{-
keyValuePairWith
(.=)
parseUntaggedValue
parseTaggedObject
parseValue
consToValue
toPair
sumToValue

todo: check what the different encoding of 'String' will change (will it change tags? I guess it shouldn't)
-}

----------------------------------------------------------------------------
-- Assorted stuff ripped off from Aeson
----------------------------------------------------------------------------

parseIndexedJSON :: (Value -> Parser a) -> Int -> Value -> Parser a
parseIndexedJSON p idx value = p value A.<?> A.Index idx
{-# INLINE parseIndexedJSON #-}
